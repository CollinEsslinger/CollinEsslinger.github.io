<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Feuer-Quiz – Für die Grundschule</title>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="Feuer Icon.png">
  <link rel="shortcut icon" type="image/png" href="Feuer Icon.png">
  <link rel="apple-touch-icon" href="Feuer Icon.png">

  <style>
    body {
      font-family: "Segoe UI", Tahoma, sans-serif;
      background: #fbeee6;
      margin: 0;
      padding: 0;
      color: #333;
    }

    .quiz-container {
      max-width: 800px;
      margin: 30px auto;
      padding: 20px;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    h1 { text-align: center; margin-top: 0; color: #b1382b; }

    .question { margin-bottom: 30px; }
    .question h2 { margin-top: 0; font-size: 1.2em; color: #622b00; }

    .options-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 10px;
    }

    label.option {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      background: #fafafa;
      transition: background 0.2s, border-color 0.2s;
      text-align: center;
    }
    label.option:hover { background: #f2f2f2; border-color: #b1382b; }
    label.option input { margin-bottom: 8px; transform: scale(1.3); accent-color: #b1382b; }

    /* Einheitliche Bildgröße für ALLE Bilder (Fragen, Ergebnis, Kärtchen) */
    label.option img,
    .sortable-item img {
      width: 100px;
      height: 100px;
      object-fit: contain;
      margin-bottom: 6px;
      display: block;
    }

    button.btn {
      background: #b1382b;
      color: #fff;
      border: none;
      padding: 12px 24px;
      font-size: 1rem;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 20px;
      display: block;
      width: 100%;
    }
    button.btn:hover { background: #8d2e24; }

    /* Ergebnis-Hervorhebungen */
    label.option.correct-answer { border-color: #28a745; background-color: #e9f7ef; }
    label.option.wrong-answer   { border-color: #dc3545; background-color: #fcebea; }
    label.option.unselected-correct-answer { background-color: #e9f7ef; border-color: #ddd; }

    .points-box { background: #b1382b; color: #ffffff; border-radius: 6px; padding: 4px 8px; font-size: 0.85em; display: inline-block; margin-top: 8px; }
    .points-box-wrapper { text-align: right; margin-top: 8px; }
    .summary-text { color: #b1382b; }

    .question-step { display: none; }

    /* Sortierliste & Karten */
    .sortable { list-style: none; padding: 0; margin: 10px 0 0; position: relative; }
    .sortable-item {
      display: flex;
      align-items: center;
      gap: 10px;
      border: 1px dashed #ccc;
      border-radius: 8px;
      background: #fafafa;
      padding: 10px;
      margin-bottom: 8px;
      touch-action: none; /* wichtig für Pointer/Touch */
      transition: transform 150ms ease; /* FLIP-Animation */
      cursor: grab;
    }
    .sortable-item:active { cursor: grabbing; }

    /* Platzhalter-Lücke */
    .placeholder {
      border: 2px dashed #b1382b;
      border-radius: 8px;
      background: #fff7f5;
      margin-bottom: 8px;
      height: 0; /* wird dynamisch gesetzt */
    }

    /* Die „schwebende“ gezogene Karte (hängt am Finger/Maus) */
    .drag-ghost {
      position: fixed; /* folgt dem Pointer zuverlässig */
      left: 0; top: 0;
      width: 0; /* wird dynamisch gesetzt */
      z-index: 999;
      pointer-events: none;
      box-shadow: 0 8px 24px rgba(0,0,0,0.18);
      opacity: 1; /* explizit opaque */
      transform: translate3d(0,0,0);
      transition: none; /* keine FLIP-Transition auf dem Ghost */
      background: #fafafa;
      border: 1px dashed #ccc;
      border-radius: 8px;
    }

    /* Ergebnis-Ansicht: Platz für fixen Button unten schaffen */
    .result-pad-bottom {
      padding-bottom: calc(96px + env(safe-area-inset-bottom, 0px));
    }

    /* Fixierter Mega-Button am unteren Bildschirmrand (nur in der Auswertung sichtbar) */
    .btn-fixed-bottom {
      position: fixed; left: 0; right: 0; bottom: 0; z-index: 1000;
      background: #b1382b; color: #fff; border: none; font-size: 1.25rem;
      padding: 18px 24px; border-radius: 0; width: 100%; cursor: pointer;
      box-shadow: 0 -4px 12px rgba(0,0,0,0.08);
      padding-bottom: calc(18px + env(safe-area-inset-bottom, 0px)); /* iOS Safe Area */
    }
    .btn-fixed-bottom:hover { background: #8d2e24; }
  </style>
</head>
<body>
  <div class="quiz-container">
    <h1>Feuer-Quiz</h1>
    <p>Woran kannst du dich erinnern? Versuche, alle Fragen richtig zu beantworten!</p>

    <form id="quizForm">
      <!-- Schritt 1 -->
      <div class="question-step" id="step1" style="display: block;">
        <div class="question">
          <h2>1. Was braucht man alles, um Feuer zu machen?</h2>
          <p>(Mehrere Antworten sind möglich)</p>
          <div class="options-grid">
            <label class="option"><input type="checkbox" name="q1" value="Feuerstein" /><img src="1.1 Feuerstein.jpg" alt="Feuerstein" /><span>Feuerstein</span></label>
            <label class="option"><input type="checkbox" name="q1" value="Sonnenblumenkerne" /><img src="1.2 Sonnenblumenkerne.jpg" alt="Sonnenblumenkerne" /><span>Sonnenblumenkerne</span></label>
            <label class="option"><input type="checkbox" name="q1" value="Zunder" /><img src="1.3 Zunder.jpg" alt="Zunder" /><span>Zunder</span></label>
            <label class="option"><input type="checkbox" name="q1" value="Stück Stahl" /><img src="1.4 Feuerstahl.jpg" alt="Stück Stahl" /><span>Stück Stahl</span></label>
            <label class="option"><input type="checkbox" name="q1" value="Distelsamen" /><img src="1.5 Distelsamen.jpg" alt="Distelsamen" /><span>Distelsamen</span></label>
            <label class="option"><input type="checkbox" name="q1" value="Aluminium-Stab" /><img src="1.6 Aluminium-Stab.jpg" alt="Aluminium-Stab" /><span>Aluminium-Stab</span></label>
            <label class="option"><input type="checkbox" name="q1" value="Stroh" /><img src="1.7 Stroh.jpg" alt="Stroh" /><span>Stroh</span></label>
            <label class="option"><input type="checkbox" name="q1" value="Holz" /><img src="1.8 Holz.jpg" alt="Holz" /><span>Holz</span></label>
          </div>
        </div>
        <button type="button" class="btn" onclick="nextStep();">Weiter</button>
      </div>

      <!-- Schritt 2 -->
      <div class="question-step" id="step2">
        <div class="question">
          <h2>2. Was braucht ein Feuer immer unbedingt, um zu brennen?</h2>
          <div class="options-grid">
            <label class="option"><input type="radio" name="q2" value="Wachs" /><img src="2.1 Wachs.jpg" alt="Wachs" /><span>Wachs</span></label>
            <label class="option"><input type="radio" name="q2" value="Wasser" /><img src="2.2 Wasser.jpg" alt="Wasser" /><span>Wasser</span></label>
            <label class="option"><input type="radio" name="q2" value="Luft" /><img src="2.3 Luft.jpg" alt="Luft" /><span>Luft</span></label>
            <label class="option"><input type="radio" name="q2" value="Feuerzeug" /><img src="2.4 Feuerzeug.jpg" alt="Feuerzeug" /><span>Feuerzeug</span></label>
          </div>
        </div>
        <button type="button" class="btn" onclick="nextStep();">Weiter</button>
      </div>

      <!-- Schritt 3 -->
      <div class="question-step" id="step3">
        <div class="question">
          <h2>3. Was nutzt Martin, um nicht die ganze Zeit mit dem Mund zu blasen?</h2>
          <div class="options-grid">
            <label class="option"><input type="radio" name="q3" value="Luftpumpe" /><img src="3.1 Luftpumpe.jpg" alt="Luftpumpe" /><span>Luftpumpe</span></label>
            <label class="option"><input type="radio" name="q3" value="Blasebalg" /><img src="3.2 Blasebalg.jpg" alt="Blasebalg" /><span>Blasebalg</span></label>
            <label class="option"><input type="radio" name="q3" value="Hände" /><img src="3.3 Haende.jpg" alt="Hände" /><span>Hände</span></label>
            <label class="option"><input type="radio" name="q3" value="Blasrohr" /><img src="3.4 Blasrohr.jpg" alt="Blasrohr" /><span>Blasrohr</span></label>
          </div>
        </div>
        <button type="button" class="btn" onclick="nextStep();">Weiter</button>
      </div>

      <!-- Schritt 4: Reihenfolge -->
      <div class="question-step" id="step4">
        <div class="question">
          <h2>4. Bringe die Schritte zum Feuer machen in die richtige Reihenfolge.</h2>
          <p>Ziehe die Kärtchen an die richtige Position.</p>
          <ul id="q4-list" class="sortable">
            <li class="sortable-item" data-id="ZunderDistelsamen" data-correct-pos="2">
              <img src="4.2 ZunderDistelsamen.jpg" alt="Zunder in Distelsamen legen">
              <span class="title">Zunder in Distelsamen legen</span>
            </li>
            <li class="sortable-item" data-id="StrohBlasebalg" data-correct-pos="4">
              <img src="4.4 StrohBlasebalg.jpg" alt="Stroh mit Blasebalg anfeuern">
              <span class="title">Stroh mit Blasebalg anfeuern</span>
            </li>
            <li class="sortable-item" data-id="ZunderFeuerstein" data-correct-pos="1">
              <img src="4.1 ZunderFeuerstein.jpg" alt="Zunder am Feuerstein zum Glimmen bringen">
              <span class="title">Zunder am Feuerstein zum Glimmen bringen</span>
            </li>
            <li class="sortable-item" data-id="StrohHolz" data-correct-pos="5">
              <img src="4.5 StrohHolz.jpg" alt="Holz-Stückchen auf brennendes Stroh legen">
              <span class="title">Holz-Stückchen auf brennendes Stroh legen</span>
            </li>
            <li class="sortable-item" data-id="DistelsamenStroh" data-correct-pos="3">
              <img src="4.3 DistelsamenStroh.jpg" alt="qualmenden Distelsamen in Stroh einpacken">
              <span class="title">qualmenden Distelsamen in Stroh einpacken</span>
            </li>
          </ul>
        </div>
        <button type="button" class="btn" onclick="submitQuiz();">Überprüfen</button>
      </div>

      <!-- Ergebnis -->
      <div class="question-step" id="step5" style="display: none;"></div>
    </form>
  </div>

  <script>
    let currentStep = 1;
    let q4InitialHTML = '';

    function nextStep() {
      document.getElementById('step' + currentStep).style.display = 'none';
      currentStep++;
      const nextDiv = document.getElementById('step' + currentStep);
      nextDiv.style.display = 'block';
      nextDiv.scrollIntoView({ behavior: 'smooth' });
    }

    /* ---------------------------
       Sortier-Logik mit Pointer + FLIP
       --------------------------- */
    function enableSortableWithSnap(ul) {
      let dragging = null;             // Referenz auf Original-Element
      let ghost = null;                // schwebende Kopie
      let placeholder = null;          // Lücke im Flow
      let offsetY = 0;                 // Finger/Maus-Offset innerhalb der Karte
      let listRect = null;             // BoundingRect der Liste
      let ghostWidth = 0;
      let started = false;

      const items = () => Array.from(ul.querySelectorAll('.sortable-item'));
      const siblings = () => items().filter(el => el !== dragging);

      // Hilfsfunktion: FLIP-Animation für alle Siblings
      function flipAnimate(beforeRects) {
        const els = siblings();
        els.forEach((el, i) => {
          const first = beforeRects.get(el);
          const last = el.getBoundingClientRect();
          if (!first) return;
          const dx = first.left - last.left;
          const dy = first.top  - last.top;
          if (dx || dy) {
            el.style.transform = `translate(${dx}px, ${dy}px)`;
            el.style.transition = 'transform 0s';
            requestAnimationFrame(() => {
              el.style.transition = 'transform 150ms ease';
              el.style.transform = '';
            });
          }
        });
      }

      function recordRects() {
        const map = new Map();
        siblings().forEach(el => map.set(el, el.getBoundingClientRect()));
        return map;
      }

      function onPointerDown(e) {
        const target = e.target.closest('.sortable-item');
        if (!target) return;
        e.preventDefault();
        started = true;
        dragging = target;

        // Liste & Maße erfassen
        listRect = ul.getBoundingClientRect();

        const rect = dragging.getBoundingClientRect();
        ghostWidth = rect.width;

        // Offset innerhalb der Karte merken, damit der Fingerpunkt „klebt“
        offsetY = e.clientY - rect.top;

        // Platzhalter einfügen
        placeholder = document.createElement('li');
        placeholder.className = 'placeholder';
        placeholder.style.height = rect.height + 'px';
        placeholder.style.marginBottom = getComputedStyle(dragging).marginBottom;
        ul.insertBefore(placeholder, dragging.nextSibling);

        // Dragging-Element aus dem Flow nehmen (per Ghost ersetzen)
        ghost = dragging.cloneNode(true);
        ghost.classList.add('drag-ghost');
        ghost.style.width = rect.width + 'px';
        ghost.style.height = rect.height + 'px';
        document.body.appendChild(ghost);

        // Original unsichtbar machen, aber im DOM lassen (für einfaches Einfügen)
        dragging.style.visibility = 'hidden';

        // Erste Position setzen
        moveGhost(e.clientX, e.clientY);

        // Events binden
        window.addEventListener('pointermove', onPointerMove, { passive: false });
        window.addEventListener('pointerup', onPointerUp, { passive: false });
      }

      function moveGhost(clientX, clientY) {
        const x = Math.min(Math.max(clientX, 0), window.innerWidth);
        const y = clientY - offsetY;
        ghost.style.transform = `translate(${x - ghostWidth/2}px, ${y}px)`;
      }

      function onPointerMove(e) {
        if (!started || !dragging) return;
        e.preventDefault();

        moveGhost(e.clientX, e.clientY);

        const beforeRects = recordRects();

        // Mittelpunkt der Ghost-Karte:
        const ghostRect = ghost.getBoundingClientRect();
        const centerY = ghostRect.top + ghostRect.height / 2;

        // Bestimme neue Placeholder-Position
        const els = siblings();
        let placed = false;
        for (let i = 0; i < els.length; i++) {
          const r = els[i].getBoundingClientRect();
          const mid = r.top + r.height / 2;
          if (centerY < mid) {
            ul.insertBefore(placeholder, els[i]);
            placed = true;
            break;
          }
        }
        if (!placed) {
          ul.appendChild(placeholder);
        }

        // FLIP-Animation für nicht-gezogene Karten
        flipAnimate(beforeRects);
      }

      function onPointerUp(e) {
        if (!started) return;
        started = false;

        // In die Lücke snappen
        ul.insertBefore(dragging, placeholder);
        dragging.style.visibility = '';
        // Aufräumen
        placeholder.remove();
        ghost.remove();
        placeholder = null;
        ghost = null;

        window.removeEventListener('pointermove', onPointerMove);
        window.removeEventListener('pointerup', onPointerUp);

        dragging = null;
      }

      // Doppelte Handler verhindern: Liste klonen und ersetzen
      const fresh = ul.cloneNode(true);
      ul.parentNode.replaceChild(fresh, ul);

      // Pointer-Start auf Items
      fresh.addEventListener('pointerdown', onPointerDown, { passive: false });
    }

    /* ----------- Drag & Touch Sortable initialisieren ----------- */
    function initDragDrop() {
      const list = document.getElementById('q4-list');
      if (!list) return;
      enableSortableWithSnap(list);
    }

    // Initial: Reihenfolge merken + Sortable binden
    window.addEventListener('DOMContentLoaded', () => {
      const list = document.getElementById('q4-list');
      if (list) q4InitialHTML = list.innerHTML;
      initDragDrop();
    });

    function resetQuiz() {
      // Fixierten Button entfernen
      const fixedBtn = document.getElementById('play-again-fixed');
      if (fixedBtn) fixedBtn.remove();

      // Alle Inputs leeren
      document.querySelectorAll('input[type="checkbox"], input[type="radio"]').forEach(i => i.checked = false);

      // Kärtchen auf Ursprungszustand zurücksetzen und neu binden
      const list = document.getElementById('q4-list');
      if (list && q4InitialHTML) {
        list.innerHTML = q4InitialHTML;
        initDragDrop();
      }

      // Zurück zu Schritt 1
      document.querySelectorAll('.question-step').forEach(step => step.style.display = 'none');
      currentStep = 1;
      document.getElementById('step1').style.display = 'block';
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }

    /* ---------------------------
       Bewertungslogik (unverändert)
       --------------------------- */
    function submitQuiz() {
      // Frage 1 (0..10)
      const q1Correct = new Set(["Feuerstein","Zunder","Stück Stahl","Distelsamen","Stroh","Holz"]);
      const q1Selections = Array.from(document.querySelectorAll('input[name="q1"]:checked')).map(el => el.value);
      let q1Points = 0;
      q1Selections.forEach(val => {
        if (q1Correct.has(val)) q1Points += 10 / q1Correct.size; // +10/6 pro richtige
        else q1Points -= 1;                                      // -1 pro falsche
      });
      q1Points = Math.round(Math.max(0, Math.min(10, q1Points))); // ganze Zahl, 0..10

      // Frage 2 (0..5)
      const q2Correct = "Luft";
      const q2Sel = document.querySelector('input[name="q2"]:checked');
      const q2Points = (q2Sel && q2Sel.value === q2Correct) ? 5 : 0;

      // Frage 3 (0..5)
      const q3Correct = "Blasebalg";
      const q3Sel = document.querySelector('input[name="q3"]:checked');
      const q3Points = (q3Sel && q3Sel.value === q3Correct) ? 5 : 0;

      // Frage 4 (0..10)
      const list = document.getElementById('q4-list');
      const items = Array.from(list.querySelectorAll('.sortable-item'));
      let correctInPlace = 0;
      items.forEach((li, idx) => { if (Number(li.dataset.correctPos) === idx + 1) correctInPlace++; });
      let q4Points = Math.round((correctInPlace / items.length) * 10);
      q4Points = Math.max(0, Math.min(10, q4Points));

      // Gesamtpunkte (max 30)
      const score = q1Points + q2Points + q3Points + q4Points;
      const maxScore = 30;

      const feedbackSummary =
        score === maxScore ? 'Super! Du hast alles richtig gemacht!' :
        score >= 22 ? 'Sehr gut! Du bist fast bei der vollen Punktzahl.' :
        score >= 12 ? 'Gut gemacht! Übe noch etwas und versuche es erneut.' :
        'Du hast noch etwas Übung nötig – probiere es später noch einmal!';

      /* --- Ergebnisdarstellung --- */
      const q1Images = {
        'Feuerstein':'1.1 Feuerstein.jpg','Sonnenblumenkerne':'1.2 Sonnenblumenkerne.jpg','Zunder':'1.3 Zunder.jpg',
        'Stück Stahl':'1.4 Feuerstahl.jpg','Aluminium-Stab':'1.6 Aluminium-Stab.jpg','Distelsamen':'1.5 Distelsamen.jpg',
        'Stroh':'1.7 Stroh.jpg','Holz':'1.8 Holz.jpg'
      };
      const q2Images = {'Wachs':'2.1 Wachs.jpg','Wasser':'2.2 Wasser.jpg','Luft':'2.3 Luft.jpg','Feuerzeug':'2.4 Feuerzeug.jpg'};
      const q3Images = {'Luftpumpe':'3.1 Luftpumpe.jpg','Blasebalg':'3.2 Blasebalg.jpg','Hände':'3.3 Haende.jpg','Blasrohr':'3.4 Blasrohr.jpg'};

      function buildResultSection(title, options, type, correctSet, selectedList, pointsEarned, pointsMax, imgMap){
        let section = `<div class="question"><h3>${title}</h3><div class="options-grid">`;
        options.forEach(opt=>{
          const selected = selectedList.includes(opt);
          const isCorrect = correctSet.has(opt);
          let cls = selected && isCorrect ? 'correct-answer'
                  : selected && !isCorrect ? 'wrong-answer'
                  : !selected && isCorrect ? 'unselected-correct-answer' : '';
          section += `
            <label class="option ${cls}">
              <input type="${type}" disabled ${selected ? 'checked' : ''}/>
              <img src="${imgMap[opt] || ''}" alt="${opt}"/>
              <span>${opt}</span>
            </label>`;
        });
        section += `</div><div class="points-box-wrapper"><span class="points-box">${pointsEarned}/${pointsMax}</span></div></div>`;
        return section;
      }

      function buildOrderResultSection(title, items, pointsEarned, pointsMax) {
        let section = `<div class="question"><h3>${title}</h3><ul class="sortable">`;
        items.forEach((li) => {
          const currentPos = Array.from(li.parentNode.children).indexOf(li) + 1;
          const targetPos = Number(li.getAttribute('data-correct-pos'));
          const ok = currentPos === targetPos;
          section += `
            <li class="sortable-item" style="cursor: default; ${ok ? 'border-color:#28a745;background:#e9f7ef;' : ''}">
              ${li.querySelector('img').outerHTML}
              <span class="title">${li.querySelector('.title').textContent}</span>
            </li>`;
        });
        section += `</ul><div class="points-box-wrapper"><span class="points-box">${pointsEarned}/${pointsMax}</span></div></div>`;
        return section;
      }

      const q1ResultSection = buildResultSection(
        'Frage 1: Was braucht man alles, um Feuer zu machen?',
        Object.keys(q1Images), 'checkbox', new Set(['Feuerstein','Zunder','Stück Stahl','Distelsamen','Stroh','Holz']), q1Selections,  q1Points, 10, q1Images
      );
      const q2ResultSection = buildResultSection(
        'Frage 2: Was braucht ein Feuer immer unbedingt, um zu brennen?',
        Object.keys(q2Images), 'radio', new Set(['Luft']),  q2Sel ? [q2Sel.value] : [], q2Points, 5, q2Images
      );
      const q3ResultSection = buildResultSection(
        'Frage 3: Was nutzt Martin, um nicht die ganze Zeit mit dem Mund zu blasen?',
        Object.keys(q3Images), 'radio', new Set(['Blasebalg']), q3Sel ? [q3Sel.value] : [], q3Points, 5, q3Images
      );
      const q4ResultSection = buildOrderResultSection(
        'Frage 4: Schritte in die richtige Reihenfolge bringen',
        items, q4Points, 10
      );

      const step5Div = document.getElementById('step5');
      step5Div.classList.add('result-step', 'result-pad-bottom');
      step5Div.innerHTML = `
        <div class="question">
          <h2>Ergebnis</h2>
          <p class="summary-text">Du hast <strong>${score} von ${maxScore}</strong> Punkten erreicht.</p>
          <p>${feedbackSummary}</p>
        </div>
        ${q1ResultSection}
        ${q2ResultSection}
        ${q3ResultSection}
        ${q4ResultSection}
        <div class="points-box-wrapper"><span class="points-box">gesamt: ${score}/${maxScore}</span></div>
      `;

      // Fixierten "Nochmal spielen"-Button neu erzeugen
      const oldFixedBtn = document.getElementById('play-again-fixed');
      if (oldFixedBtn) oldFixedBtn.remove();
      const fixedBtn = document.createElement('button');
      fixedBtn.id = 'play-again-fixed';
      fixedBtn.className = 'btn-fixed-bottom';
      fixedBtn.type = 'button';
      fixedBtn.textContent = '🔁 Nochmal spielen';
      fixedBtn.addEventListener('click', resetQuiz);
      document.body.appendChild(fixedBtn);

      // Ansicht umschalten
      document.getElementById('step4').style.display = 'none';
      step5Div.style.display = 'block';
      step5Div.scrollIntoView({ behavior: 'smooth' });
    }
  </script>
</body>
</html>
